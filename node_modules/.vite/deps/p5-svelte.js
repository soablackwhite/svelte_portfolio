import "./chunk-QA2HOWKX.js";
import "./chunk-U72A433S.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  attr_dev,
  children,
  claim_element,
  createEventDispatcher,
  detach_dev,
  dispatch_dev,
  element,
  globals,
  init,
  insert_hydration_dev,
  noop,
  onMount,
  safe_not_equal,
  validate_slots
} from "./chunk-SRABX7UM.js";
import "./chunk-PPILITPA.js";
import "./chunk-NEAGQJHQ.js";

// node_modules/.pnpm/p5-svelte@3.1.2_@types+p5@1.7.6_p5@1.9.0/node_modules/p5-svelte/P5.svelte
var { Object: Object_1, console: console_1 } = globals;
var file = "node_modules/.pnpm/p5-svelte@3.1.2_@types+p5@1.7.6_p5@1.9.0/node_modules/p5-svelte/P5.svelte";
function create_fragment(ctx) {
  let div;
  let ref_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true, class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "style",
        /*parentDivStyle*/
        ctx[0]
      );
      attr_dev(div, "class", "m-0");
      add_location(div, file, 60, 0, 1647);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(ref_action = /*ref*/
        ctx[1].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*parentDivStyle*/
      1) {
        attr_dev(
          div,
          "style",
          /*parentDivStyle*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function augmentClasses(instance2, classes) {
  classes.forEach(([key, value]) => instance2[key] = value);
  return instance2;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("P5", slots, []);
  let { target = void 0 } = $$props;
  let { sketch = void 0 } = $$props;
  let { parentDivStyle = "display: block;" } = $$props;
  let { debug = false } = $$props;
  let project = void 0;
  const event = createEventDispatcher();
  const dispatch = {
    ref() {
      event("ref", target);
    },
    instance() {
      event("instance", project);
    }
  };
  function ref(node) {
    $$invalidate(2, target = node);
    return {
      destroy() {
        $$invalidate(2, target = void 0);
      }
    };
  }
  onMount(async () => {
    const library = await import("./p5.min-MTZ5V5AN.js");
    const { default: p5 } = library;
    const entries = Object.entries(library);
    const nativeClasses = entries.filter(([key, value]) => value instanceof Function && key[0] !== "_" && key !== "default");
    if (debug) {
      console.log("available p5 native classes", nativeClasses);
    }
    project = new p5(
      (instance2) => {
        instance2 = augmentClasses(instance2, nativeClasses);
        if (debug) {
          console.log("p5 instance", instance2);
        }
        window._p5Instance = instance2;
        return sketch(instance2);
      },
      target
    );
    dispatch.ref();
    dispatch.instance();
  });
  const writable_props = ["target", "sketch", "parentDivStyle", "debug"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<P5> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(2, target = $$props2.target);
    if ("sketch" in $$props2)
      $$invalidate(3, sketch = $$props2.sketch);
    if ("parentDivStyle" in $$props2)
      $$invalidate(0, parentDivStyle = $$props2.parentDivStyle);
    if ("debug" in $$props2)
      $$invalidate(4, debug = $$props2.debug);
  };
  $$self.$capture_state = () => ({
    onMount,
    createEventDispatcher,
    target,
    sketch,
    parentDivStyle,
    debug,
    project,
    event,
    dispatch,
    ref,
    augmentClasses
  });
  $$self.$inject_state = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(2, target = $$props2.target);
    if ("sketch" in $$props2)
      $$invalidate(3, sketch = $$props2.sketch);
    if ("parentDivStyle" in $$props2)
      $$invalidate(0, parentDivStyle = $$props2.parentDivStyle);
    if ("debug" in $$props2)
      $$invalidate(4, debug = $$props2.debug);
    if ("project" in $$props2)
      project = $$props2.project;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [parentDivStyle, ref, target, sketch, debug];
}
var P5 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      target: 2,
      sketch: 3,
      parentDivStyle: 0,
      debug: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "P5",
      options,
      id: create_fragment.name
    });
  }
  get target() {
    throw new Error("<P5>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<P5>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sketch() {
    throw new Error("<P5>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sketch(value) {
    throw new Error("<P5>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parentDivStyle() {
    throw new Error("<P5>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parentDivStyle(value) {
    throw new Error("<P5>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debug() {
    throw new Error("<P5>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debug(value) {
    throw new Error("<P5>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var P5_default = P5;
export {
  P5_default as default
};
//# sourceMappingURL=p5-svelte.js.map
